import { create } from 'zustand';

// --- MOCK DATA ---
// This data simulates what would come from a database.

// 1. Catálogo de Productos (Información General)
const localProducts = [
  { id: 'prod1', name: 'Arroz 1kg', price: 25.50, wholesalePrice: 22.00, unitOfMeasure: 'kg', barcodes: ['123456789001'], image: 'https://placehold.co/60x60/4f46e5/white?text=AR', minStockThreshold: { 'tienda1': 10, 'tienda2': 10, 'bodega-central': 50 }, categoryId: 'cat1', subcategoryId: null },
  { id: 'prod2', name: 'Frijoles 1kg', price: 32.00, wholesalePrice: 28.00, unitOfMeasure: 'kg', barcodes: ['123456789002'], image: 'https://placehold.co/60x60/059669/white?text=FR', minStockThreshold: { 'tienda1': 10, 'tienda2': 10, 'bodega-central': 50 }, categoryId: 'cat1', subcategoryId: null },
  { id: 'prod3', name: 'Cerveza Modelo 355ml', price: 18.75, wholesalePrice: 15.00, unitOfMeasure: 'unidad', barcodes: ['123456789004'], image: 'https://placehold.co/60x60/ea580c/white?text=CM', minStockThreshold: { 'tienda1': 24, 'tienda2': 24, 'bodega-central': 100 }, categoryId: 'cat2', subcategoryId: null },
  { id: 'prod4', name: 'Jabón Dove 125g', price: 22.50, wholesalePrice: 19.00, unitOfMeasure: 'unidad', barcodes: ['123456789008'], image: 'https://placehold.co/60x60/8b5cf6/white?text=JD', minStockThreshold: { 'tienda1': 5, 'tienda2': 5, 'bodega-central': 20 }, categoryId: 'cat1', subcategoryId: null },
];

// 2. Lotes de Inventario (Stock real por ubicación con caducidad)
const localInventoryBatches = [
  // Lotes de Arroz
  { inventoryId: 'inv1', productId: 'prod1', locationId: 'bodega-central', quantity: 100, cost: 18.00, expirationDate: '2026-12-31' },
  { inventoryId: 'inv2', productId: 'prod1', locationId: 'tienda1', quantity: 8, cost: 18.50, expirationDate: '2026-10-20' }, // Stock bajo
  { inventoryId: 'inv3', productId: 'prod1', locationId: 'tienda2', quantity: 15, cost: 18.50, expirationDate: '2026-10-20' },

  // Lotes de Frijoles
  { inventoryId: 'inv4', productId: 'prod2', locationId: 'bodega-central', quantity: 80, cost: 22.00, expirationDate: '2027-01-15' },

  // Lotes de Cerveza
  { inventoryId: 'inv5', productId: 'prod3', locationId: 'tienda1', quantity: 30, cost: 12.00, expirationDate: '2025-11-10' }, // Próximo a vencer
  { inventoryId: 'inv6', productId: 'prod3', locationId: 'tienda2', quantity: 40, cost: 12.00, expirationDate: '2026-08-01' },

  // Lotes de Jabón
  { inventoryId: 'inv7', productId: 'prod4', locationId: 'tienda1', quantity: 3, cost: 15.00, expirationDate: null }, // Stock muy bajo
];

// 3. Otros datos locales
const localUsers = [
    { uid: 'admin123', email: 'admin@racom.com', password: 'admin123', role: 'admin', name: 'Administrador Principal', storeId: 'tienda1' },
    { uid: 'gerente123', email: 'gerente@racom.com', password: 'gerente123', role: 'gerente', name: 'Gerente General', storeId: 'tienda1' },
    { uid: 'cajera123', email: 'cajera1@racom.com', password: 'cajera123', role: 'cashier', name: 'Cajera Tienda 1', storeId: 'tienda1' },
    { uid: 'cajera223', email: 'cajera2@racom.com', password: 'cajera123', role: 'cashier', name: 'Cajera Tienda 2', storeId: 'tienda2' },
    { uid: 'bodeguero123', email: 'bodega@racom.com', password: 'bodega123', role: 'bodeguero', name: 'Operador de Bodega', storeId: 'bodega-central' },
];
const localCategories = [ { id: 'cat1', name: 'Abarrotes', parentId: null, subcategories: [] }, { id: 'cat2', name: 'Vicio', parentId: null, subcategories: [] }, { id: 'cat3', name: 'Bebidas', parentId: null, subcategories: [] } ];
const localStores = [ { id: 'bodega-central', name: 'Bodega Central' }, { id: 'tienda1', name: 'Tienda 1' }, { id: 'tienda2', name: 'Tienda 2' } ];


const useAppStore = create((set, get) => ({
  // --- STATE ---
  currentUser: null,
  currentView: 'login',
  activeTab: 'pos',
  cart: [],
  discount: { type: 'none', value: 0 }, // New discount state
  note: '', // New note state
  lastSale: null, // To store the last sale details for ticket printing
  darkMode: false, // New state for dark mode
  
  // Catálogos
  products: [],
  categories: [],
  users: [],
  stores: [],
  clients: [], // New state for clients

  // Datos transaccionales
  inventoryBatches: [],
  transfers: [],
  salesHistory: [],
  expenses: [],
  shoppingList: [], // New state for shopping list
  cashClosings: [],

  setDiscount: (newDiscount) => set({ discount: newDiscount }), // New action to set discount
  setNote: (newNote) => set({ note: newNote }), // New action to set note
  addToShoppingList: (item) => set(state => ({ shoppingList: [...state.shoppingList, item] })), // New action to add to shopping list
  clearShoppingList: () => set({ shoppingList: [] }), // New action to clear shopping list
  toggleDarkMode: () => {
    const newDarkMode = !get().darkMode;
    set({ darkMode: newDarkMode });
    // Save preference to localStorage
    localStorage.setItem('darkMode', JSON.stringify(newDarkMode));
  },

  // --- LÓGICA DE CLIENTES ---
  addClient: (clientData) => {
    const newClient = { ...clientData, id: `client-${Date.now()}`, creditBalance: 0 };
    set(state => ({ clients: [...state.clients, newClient] }));
  },
  updateClient: (id, updatedData) => {
    set(state => ({
      clients: state.clients.map(client => client.id === id ? { ...client, ...updatedData } : client)
    }));
  },
  deleteClient: (id) => {
    set(state => ({
      clients: state.clients.filter(client => client.id !== id)
    }));
  },
  grantCredit: (clientId, amount) => {
    set(state => ({
      clients: state.clients.map(client => 
        client.id === clientId 
        ? { ...client, creditBalance: client.creditBalance + amount } 
        : client
      )
    }));
  },
  recordPayment: (clientId, amount) => {
    set(state => ({
      clients: state.clients.map(client => 
        client.id === clientId 
        ? { ...client, creditBalance: client.creditBalance - amount } 
        : client
      )
    }));
  },
  liquidateCredit: (clientId) => {
    set(state => ({
      clients: state.clients.map(client => 
        client.id === clientId 
        ? { ...client, creditBalance: 0 } 
        : client
      )
    }));
  },
  addReminder: (reminderData) => {
    const newReminder = { ...reminderData, id: `rem-${Date.now()}`, isConcluded: false, createdAt: new Date().toISOString() };
    set(state => ({ reminders: [...state.reminders, newReminder] }));
  },

  markReminderAsConcluded: (id) => {
    set(state => ({
      reminders: state.reminders.map(rem => rem.id === id ? { ...rem, isConcluded: true } : rem)
    }));
  },
  // --- LÓGICA DE TRANSFERENCIAS ---
  createTransferRequest: ({ items }) => {
    const { currentUser, stores } = get();
    const destinationStore = stores.find(s => s.id === currentUser.storeId);

    if (!destinationStore) {
      console.error("Cannot create transfer request: User has no assigned store.");
      return;
    }

    const newTransfer = {
      id: `TR-${Date.now()}`,
      originLocationId: 'bodega-central',
      destinationLocationId: destinationStore.id,
      requestedBy: currentUser.uid,
      createdAt: new Date().toISOString(),
      status: 'solicitado',
      items: items, // [{ productId, productName, requestedQuantity }]
      history: [{ status: 'solicitado', date: new Date().toISOString(), userId: currentUser.uid }],
    };

    set(state => ({
      transfers: [...state.transfers, newTransfer]
    }));
  },

  alerts: [],
  reminders: [], // New state for reminders

  // Configuración
  alertSettings: {
    daysBeforeExpiration: 30,
    cardCommissionRate: 0.04, // 4% commission
  },

  // --- ACTIONS ---

  // Inicialización
  initialize: () => {
    set({
      products: localProducts,
      categories: localCategories,
      users: localUsers,
      stores: localStores,
      inventoryBatches: localInventoryBatches,
    });
    get().checkAllAlerts();
  },

  // Autenticación
  handleLogin: (email, password) => {
    const user = localUsers.find(u => u.email === email && u.password === password);
    if (user) {
      set({
        currentUser: user,
        currentView: user.role === 'admin' || user.role === 'gerente' ? 'admin-dashboard' : 'pos',
      });
      get().initialize();
      return { success: true, user };
    }
    return { success: false, error: "Credenciales inválidas" };
  },
  handleLogout: () => set({ currentUser: null, currentView: 'login', cart: [] }),

  // Navegación
  setCurrentView: (view) => set({ currentView: view }),
  setActiveTab: (tab) => set({ activeTab: tab }),

  // Carrito
  addToCart: (product) => {
    const { currentUser, inventoryBatches, cart } = get();
    const storeId = currentUser?.storeId;

    if (!storeId) {
      console.error("No store ID found for current user. Cannot add to cart.");
      return;
    }

    const stockInLocation = inventoryBatches
      .filter(batch => batch.productId === product.id && batch.locationId === storeId)
      .reduce((sum, batch) => sum + batch.quantity, 0);

    const itemInCart = cart.find(item => item.id === product.id);
    const quantityInCart = itemInCart ? itemInCart.quantity : 0;

    if (quantityInCart >= stockInLocation) {
      console.warn(`Cannot add more ${product.name} to cart. Stock limit reached.`);
      // Here you would typically show a user-facing error message.
      return; 
    }

    set((state) => {
      const existingItem = state.cart.find(item => item.id === product.id);
      if (existingItem) {
        return {
          cart: state.cart.map(item =>
            item.id === product.id ? { ...item, quantity: item.quantity + 1 } : item
          ),
        };
      } else {
        return {
          cart: [...state.cart, { ...product, quantity: 1 }],
        };
      }
    });
  },
  removeFromCart: (productId) => set((state) => ({
    cart: state.cart.filter(item => item.id !== productId),
  })),

  updateCartItemQuantity: (productId, quantity) => set((state) => ({
    cart: state.cart.map(item =>
      item.id === productId ? { ...item, quantity: quantity } : item
    ).filter(item => item.quantity > 0),
  })),

  handleCheckout: (payment) => {
    const { cart, currentUser, inventoryBatches, discount, note } = get();
    const { cash, card, cardCommission, commissionInCash } = payment;
    const storeId = currentUser?.storeId;

    if (!storeId) {
      console.error("Checkout failed: No store ID for current user.");
      return;
    }

    let updatedBatches = JSON.parse(JSON.stringify(inventoryBatches)); // Deep copy to avoid mutation issues

    for (const item of cart) {
      let quantityToDeduct = item.quantity;

      const relevantBatches = updatedBatches
        .filter(b => b.productId === item.id && b.locationId === storeId)
        .sort((a, b) => new Date(a.expirationDate) - new Date(b.expirationDate));

      for (const batch of relevantBatches) {
        if (quantityToDeduct <= 0) break;

        const deductAmount = Math.min(quantityToDeduct, batch.quantity);
        batch.quantity -= deductAmount;
        quantityToDeduct -= deductAmount;
      }
    }

    const subtotal = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);
    let finalTotal = subtotal;

    if (discount.type === 'percentage') {
      finalTotal = subtotal * (1 - discount.value / 100);
    } else if (discount.type === 'amount') {
      finalTotal = subtotal - discount.value;
    }

    // Apply card commission
    if (cardCommission > 0 && !commissionInCash) {
      finalTotal += cardCommission;
    }

    const saleDetails = {
      saleId: `SALE-${Date.now()}`,
      date: new Date().toISOString(),
      cart: cart,
      subtotal: subtotal,
      discount: discount,
      note: note,
      total: finalTotal,
      cash: cash,
      card: card,
      cardCommission: cardCommission,
      commissionInCash: commissionInCash,
      cashier: currentUser ? currentUser.name : 'Unknown',
      storeId: storeId,
    };

    set({ 
      cart: [], 
      lastSale: saleDetails, 
      inventoryBatches: updatedBatches.filter(b => b.quantity > 0),
      salesHistory: [...get().salesHistory, saleDetails], // Add sale to history
      discount: { type: 'none', value: 0 }, // Reset discount after checkout
      note: '', // Reset note after checkout
    });

    get().checkAllAlerts();
  },

  // --- LÓGICA DE TRANSFERENCIAS ---
  createTransferRequest: ({ items }) => {
    const { currentUser, stores } = get();
    const destinationStore = stores.find(s => s.id === currentUser.storeId);

    if (!destinationStore) {
      console.error("Cannot create transfer request: User has no assigned store.");
      return;
    }

    const newTransfer = {
      id: `TR-${Date.now()}`,
      originLocationId: 'bodega-central',
      destinationLocationId: destinationStore.id,
      requestedBy: currentUser.uid,
      createdAt: new Date().toISOString(),
      status: 'solicitado',
      items: items, // [{ productId, productName, requestedQuantity }]
      history: [{ status: 'solicitado', date: new Date().toISOString(), userId: currentUser.uid }],
    };

    set(state => ({
      transfers: [...state.transfers, newTransfer]
    }));
  },

  approveTransfer: (transferId) => {
    set(state => ({
      transfers: state.transfers.map(t => 
        t.id === transferId 
        ? { 
            ...t, 
            status: 'aprobado', 
            history: [...t.history, { status: 'aprobado', date: new Date().toISOString(), userId: get().currentUser.uid }]
          } 
        : t
      )
    }));
  },

  shipTransfer: (transferId, sentItems) => {
    const { inventoryBatches } = get();
    let updatedBatches = JSON.parse(JSON.stringify(inventoryBatches));

    // Deduct stock from origin (bodega-central)
    for (const item of sentItems) {
      let quantityToDeduct = item.sentQuantity;
      const relevantBatches = updatedBatches
        .filter(b => b.productId === item.id && b.locationId === 'bodega-central')
        .sort((a, b) => new Date(a.expirationDate) - new Date(b.expirationDate));

      for (const batch of relevantBatches) {
        if (quantityToDeduct <= 0) break;
        const deductAmount = Math.min(quantityToDeduct, batch.quantity);
        batch.quantity -= deductAmount;
        quantityToDeduct -= deductAmount;
      }
    }

    set(state => ({
      inventoryBatches: updatedBatches.filter(b => b.quantity > 0),
      transfers: state.transfers.map(t => 
        t.id === transferId 
        ? { 
            ...t, 
            status: 'enviado', 
            items: t.items.map(origItem => {
              const sentItem = sentItems.find(si => si.productId === origItem.productId);
              return sentItem ? { ...origItem, sentQuantity: sentItem.sentQuantity } : origItem;
            }),
            history: [...t.history, { status: 'enviado', date: new Date().toISOString(), userId: get().currentUser.uid }]
          } 
        : t
      )
    }));
    get().checkAllAlerts();
  },

  receiveTransfer: (transferId, receivedItems) => {
    const { inventoryBatches } = get();
    let updatedBatches = JSON.parse(JSON.stringify(inventoryBatches));
    const transfer = get().transfers.find(t => t.id === transferId);
    const destinationId = transfer.destinationLocationId;

    // Add stock to destination
    for (const item of receivedItems) {
        // This is a simplified logic. A real system would need to decide if it merges with an existing batch
        // or creates a new one. For now, we create a new batch.
        const originalItem = transfer.items.find(i => i.productId === item.productId);
        updatedBatches.push({
            inventoryId: `inv-${Date.now()}-${item.productId}`,
            productId: item.productId,
            locationId: destinationId,
            quantity: item.receivedQuantity,
            cost: originalItem?.cost || 0, // This should be improved to get the real cost from the shipped batch
            expirationDate: '2027-12-31', // This should come from the shipped batch
        });
    }

    set(state => ({
      inventoryBatches: updatedBatches,
      transfers: state.transfers.map(t => 
        t.id === transferId 
        ? { 
            ...t, 
            status: 'recibido', 
            items: t.items.map(origItem => { 
              const receivedItem = receivedItems.find(ri => ri.productId === origItem.productId);
              return receivedItem ? { ...origItem, receivedQuantity: receivedItem.receivedQuantity } : origItem;
            }),
            history: [...t.history, { status: 'recibido', date: new Date().toISOString(), userId: get().currentUser.uid }]
          } 
        : t
      )
    }));
    get().checkAllAlerts();
  },

  // --- LÓGICA DE PRODUCTOS ---
  addProduct: (productData) => {
    const { storeId, categoryId, subcategoryId, ...rest } = productData;
    const newProduct = { ...rest, id: `prod-${Date.now()}`, categoryId, subcategoryId };
    const newBatch = {
      inventoryId: `inv-${Date.now()}-${newProduct.id}`,
      productId: newProduct.id,
      locationId: storeId,
      quantity: 0, // Initial quantity is 0, it will be added later
      cost: newProduct.cost,
      expirationDate: newProduct.expirationDate || null,
    };
    set(state => ({
      products: [...state.products, newProduct],
      inventoryBatches: [...state.inventoryBatches, newBatch],
    }));
  },

  updateProduct: (id, updatedData) => {
    set(state => ({
      products: state.products.map(product => product.id === id ? { ...product, ...updatedData } : product)
    }));
  },

  deleteProduct: (id) => {
    set(state => ({
      products: state.products.filter(product => product.id !== id)
    }));
  },
  checkAllAlerts: () => {
    const { inventoryBatches, products, stores, alertSettings } = get();
    const newAlerts = [];

    // 1. Alertas de Stock Bajo
    stores.forEach(store => {
      products.forEach(product => {
        const totalStockInLocation = inventoryBatches
          .filter(batch => batch.productId === product.id && batch.locationId === store.id)
          .reduce((sum, batch) => sum + batch.quantity, 0);
        
        const threshold = product.minStockThreshold[store.id];

        if (threshold !== undefined && totalStockInLocation < threshold) {
          newAlerts.push({
            id: `low-stock-${product.id}-${store.id}`,
            type: 'Stock Bajo',
            message: `Quedan ${totalStockInLocation} de ${product.name} en ${store.name}. (Mínimo: ${threshold})`,
            isRead: false,
          });
        }
      });
    });

    // 2. Alertas de Próxima Caducidad
    const today = new Date();
    const alertDate = new Date();
    alertDate.setDate(today.getDate() + alertSettings.daysBeforeExpiration);

    inventoryBatches.forEach(batch => {
      if (batch.expirationDate) {
        const expiration = new Date(batch.expirationDate);
        if (expiration > today && expiration <= alertDate) {
          const product = products.find(p => p.id === batch.productId);
          const store = stores.find(s => s.id === batch.locationId);
          newAlerts.push({
            id: `exp-${batch.inventoryId}`,
            type: 'Próxima Caducidad',
            message: `${batch.quantity} de ${product.name} en ${store.name} vencen el ${batch.expirationDate}.`,
            isRead: false,
          });
        }
      }
    });

    set({ alerts: newAlerts });
  },

  // Acción para marcar alerta como leída
  markAlertAsRead: (alertId) => {
    set(state => ({
      alerts: state.alerts.map(a => a.id === alertId ? { ...a, isRead: true } : a),
    }));
  },

  // --- LÓGICA DE GASTOS ---
  addExpense: (expenseData) => {
    set(state => {
      let newExpenses = [];
      if (Array.isArray(expenseData)) {
        newExpenses = expenseData.map(item => ({
          id: `exp-${Date.now()}-${item.id}`,
          date: new Date().toISOString(),
          concept: item.name,
          amount: item.price * item.quantity,
          type: 'Compra Miscelánea',
          details: `Comprado desde lista de compras. Cantidad: ${item.quantity}`,
        }));
      } else {
        newExpenses.push({ ...expenseData, id: `exp-${Date.now()}`, date: new Date().toISOString() });
      }
      return { expenses: [...state.expenses, ...newExpenses] };
    });
  },
  // --- LÓGICA DE USUARIOS ---
  addUser: (userData) => {
    const newUser = { ...userData, uid: `user-${Date.now()}` };
    set(state => ({
      users: [...state.users, newUser]
    }));
  },

  updateUser: (uid, updatedData) => {
    set(state => ({
      users: state.users.map(user => user.uid === uid ? { ...user, ...updatedData } : user)
    }));
  },

  deleteUser: (uid) => {
    set(state => ({
      users: state.users.filter(user => user.uid !== uid)
    }));
  },

  // --- LÓGICA DE CATEGORÍAS ---
  addCategory: (categoryData) => {
    const newCategory = { ...categoryData, id: `cat-${Date.now()}`, subcategories: [] };
    set(state => {
      if (newCategory.parentId) {
        const parentCategory = state.categories.find(c => c.id === newCategory.parentId);
        if (parentCategory) {
          parentCategory.subcategories.push(newCategory);
          return { categories: [...state.categories] };
        }
      }
      return { categories: [...state.categories, newCategory] };
    });
  },

  updateCategory: (id, updatedData) => {
    set(state => ({
      categories: state.categories.map(category => category.id === id ? { ...category, ...updatedData } : category)
    }));
  },

  deleteCategory: (id) => {
    set(state => ({
      categories: state.categories.filter(category => category.id !== id)
    }));
  },

  handleCashClosing: (initialCash) => {
    const { salesHistory, currentUser } = get();
    const salesToClose = salesHistory.filter(sale => sale.cashier === currentUser.name);
    const totalSalesAmount = salesToClose.reduce((acc, sale) => acc + sale.total, 0);
    const totalCashSales = salesToClose.filter(sale => sale.cash).reduce((acc, sale) => acc + sale.cash, 0);
    const totalCardSales = salesToClose.filter(sale => sale.card).reduce((acc, sale) => acc + sale.card, 0);

    const cashClosing = {
      id: `cc-${Date.now()}`,
      date: new Date().toISOString(),
      cashier: currentUser.name,
      initialCash: initialCash,
      totalSalesAmount: totalSalesAmount,
      totalCashSales: totalCashSales,
      totalCardSales: totalCardSales,
      finalCash: initialCash + totalCashSales,
      sales: salesToClose,
    };
    set(state => ({
      cashClosings: [...state.cashClosings, cashClosing],
      salesHistory: state.salesHistory.filter(sale => sale.cashier !== currentUser.name),
    }));
  },

  // --- LÓGICA DE CONSUMO DE EMPLEADOS ---
  recordEmployeeConsumption: (consumedItems, consumingUser) => {
    const { inventoryBatches } = get();
    let updatedBatches = JSON.parse(JSON.stringify(inventoryBatches));

    // Deduct stock for each consumed item
    for (const item of consumedItems) {
      let quantityToDeduct = item.quantity;

      // Find and sort relevant batches (FEFO) for the consuming user's store
      const relevantBatches = updatedBatches
        .filter(b => b.productId === item.id && b.locationId === consumingUser.storeId)
        .sort((a, b) => new Date(a.expirationDate) - new Date(b.expirationDate));

      for (const batch of relevantBatches) {
        if (quantityToDeduct <= 0) break;

        const deductAmount = Math.min(quantityToDeduct, batch.quantity);
        batch.quantity -= deductAmount;
        quantityToDeduct -= deductAmount;
      }
    }

    // Record the consumption (e.g., in a separate consumption history or as a special expense)
    const consumptionRecord = {
      id: `CONS-${Date.now()}`,
      date: new Date().toISOString(),
      items: consumedItems,
      user: consumingUser.name,
      storeId: consumingUser.storeId,
      type: 'Consumo de Empleado',
    };
    console.log("Employee Consumption Recorded:", consumptionRecord);

    set({ 
      inventoryBatches: updatedBatches.filter(b => b.quantity > 0),
      // Optionally, add to a separate consumption history array
    });

    get().checkAllAlerts();
  },

  // --- LÓGICA DE CONFIGURACIÓN DE TICKET ---
  ticketSettings: {
    headerText: '¡Gracias por tu compra!',
    footerText: 'Vuelve pronto.',
    showQrCode: true,
    fontSize: 'base',
    logoUrl: '',
  },

  updateTicketSettings: (newSettings) => {
    set(state => {
      const updatedSettings = { ...state.ticketSettings, ...newSettings };
      console.log("Saving ticketSettings to localStorage:", updatedSettings);
      localStorage.setItem('ticketSettings', JSON.stringify(updatedSettings));
      return { ticketSettings: updatedSettings };
    });
  },

  updateAlertSettings: (newSettings) => {
    set(state => {
      const updatedSettings = { ...state.alertSettings, ...newSettings };
      console.log("Saving alertSettings to localStorage:", updatedSettings);
      localStorage.setItem('alertSettings', JSON.stringify(updatedSettings));
      return { alertSettings: updatedSettings };
    });
  },

  // --- ACTIONS ---

  // Inicialización
  initialize: () => {
    console.log("useAppStore initialize function called.");
    const storedTicketSettings = localStorage.getItem('ticketSettings');
    const storedDarkMode = localStorage.getItem('darkMode');
    let initialTicketSettings = get().ticketSettings; // Get default settings
    let darkModePreference = false; // Default to light mode

    if (storedTicketSettings) {
      const parsedSettings = JSON.parse(storedTicketSettings);
      console.log("Loading ticketSettings from localStorage:", parsedSettings);
      initialTicketSettings = { ...initialTicketSettings, ...parsedSettings }; // Merge with stored
    }

    if (storedDarkMode) {
      darkModePreference = JSON.parse(storedDarkMode);
    }

    set({
      products: localProducts,
      categories: localCategories,
      users: localUsers,
      stores: localStores,
      inventoryBatches: localInventoryBatches,
      ticketSettings: initialTicketSettings, // Set merged settings
      darkMode: darkModePreference, // Set dark mode preference
    });
    get().checkAllAlerts();
  },

  addUser: (userData) => {
    const newUser = { ...userData, uid: `user-${Date.now()}` };
    set(state => ({
      users: [...state.users, newUser]
    }));
  },

  updateUser: (uid, updatedData) => {
    set(state => ({
      users: state.users.map(user => user.uid === uid ? { ...user, ...updatedData } : user)
    }));
  },

  deleteUser: (uid) => {
    set(state => ({
      users: state.users.filter(user => user.uid !== uid)
    }));
  },

}));



export default useAppStore;