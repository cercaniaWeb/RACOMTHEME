import { create } from 'zustand';
import { 
  getProducts, 
  getProduct,
  addProduct, 
  updateProduct, 
  deleteProduct,
  getCategories, 
  addCategory, 
  updateCategory,
  getUsers,
  getUser,
  addUser,
  updateUser,
  getStores,
  getInventoryBatches,
  addSale,
  getClients,
  addClient,
  getTransfers,
  getShoppingList,
  getExpenses,
  getCashClosings,
  initializeFirebaseCollections
} from '../utils/firestore';
import { auth } from '../config/firebase';
import { signInWithEmailAndPassword, onAuthStateChanged } from 'firebase/auth';


const useAppStore = create((set, get) => ({
  // --- STATE ---
  currentUser: null,
  currentView: 'login',
  activeTab: 'pos',
  cart: [],
  discount: { type: 'none', value: 0 }, // New discount state
  note: '', // New note state
  lastSale: null, // To store the last sale details for ticket printing
  darkMode: false, // New state for dark mode
  
  // Catálogos
  products: [],
  categories: [],
  users: [],
  stores: [],
  clients: [], // New state for clients

  // Datos transaccionales
  inventoryBatches: [],
  transfers: [],
  salesHistory: [],
  expenses: [],
  shoppingList: [], // New state for shopping list
  cashClosings: [],

  // Loading state management
  setLoading: (key, value) => set(state => ({
    isLoading: { ...state.isLoading, [key]: value }
  })),
  
  setDiscount: (newDiscount) => set({ discount: newDiscount }), // New action to set discount
  setNote: (newNote) => set({ note: newNote }), // New action to set note
  addToShoppingList: async (item) => {
    try {
      // Add item to Firestore
      const { addDoc, collection } = await import('firebase/firestore');
      await addDoc(collection(db, 'shoppingList'), {
        ...item,
        addedAt: new Date().toISOString(),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });
      
      // Reload shopping list to reflect the change
      await get().loadShoppingList();
      
      return { success: true };
    } catch (error) {
      console.error("Error adding to shopping list:", error);
      return { success: false, error: error.message };
    }
  },
  clearShoppingList: async () => {
    try {
      // For simplicity, we'll just reload the shopping list which should be empty from Firestore
      // In a real implementation, we might want to delete items from the shopping list collection
      await get().loadShoppingList();
      
      // If we need to clear the shopping list from Firestore, we'd need to implement that logic
      // This implementation reloads from Firestore, which means it will show whatever is in Firestore
      
      return { success: true };
    } catch (error) {
      console.error("Error clearing shopping list:", error);
      return { success: false, error: error.message };
    }
  },
  toggleDarkMode: () => {
    const newDarkMode = !get().darkMode;
    set({ darkMode: newDarkMode });
    // Save preference to localStorage
    localStorage.setItem('darkMode', JSON.stringify(newDarkMode));
  },

  // --- LÓGICA DE CARGA DE DATOS DESDE FIREBASE ---
  loadProducts: async () => {
    set({ isLoading: { ...get().isLoading, products: true } });
    try {
      const products = await getProducts();
      set({ products });
    } catch (error) {
      console.error("Error loading products:", error);
    } finally {
      set({ isLoading: { ...get().isLoading, products: false } });
    }
  },

  loadCategories: async () => {
    set({ isLoading: { ...get().isLoading, categories: true } });
    try {
      const categories = await getCategories();
      set({ categories });
    } catch (error) {
      console.error("Error loading categories:", error);
    } finally {
      set({ isLoading: { ...get().isLoading, categories: false } });
    }
  },

  loadUsers: async () => {
    set({ isLoading: { ...get().isLoading, users: true } });
    try {
      const users = await getUsers();
      set({ users });
    } catch (error) {
      console.error("Error loading users:", error);
    } finally {
      set({ isLoading: { ...get().isLoading, users: false } });
    }
  },

  loadStores: async () => {
    set({ isLoading: { ...get().isLoading, stores: true } });
    try {
      const stores = await getStores();
      set({ stores });
    } catch (error) {
      console.error("Error loading stores:", error);
    } finally {
      set({ isLoading: { ...get().isLoading, stores: false } });
    }
  },

  loadInventoryBatches: async () => {
    set({ isLoading: { ...get().isLoading, inventory: true } });
    try {
      const inventoryBatches = await getInventoryBatches();
      set({ inventoryBatches });
    } catch (error) {
      console.error("Error loading inventory batches:", error);
    } finally {
      set({ isLoading: { ...get().isLoading, inventory: false } });
    }
  },

  loadSalesHistory: async () => {
    set({ isLoading: { ...get().isLoading, sales: true } });
    try {
      const salesHistory = await getSales();
      set({ salesHistory });
    } catch (error) {
      console.error("Error loading sales history:", error);
    } finally {
      set({ isLoading: { ...get().isLoading, sales: false } });
    }
  },

  loadClients: async () => {
    set({ isLoading: { ...get().isLoading, clients: true } });
    try {
      const clients = await getClients();
      set({ clients });
    } catch (error) {
      console.error("Error loading clients:", error);
    } finally {
      set({ isLoading: { ...get().isLoading, clients: false } });
    }
  },

  loadTransfers: async () => {
    try {
      const transfers = await getTransfers();
      set({ transfers });
    } catch (error) {
      console.error("Error loading transfers:", error);
    }
  },

  loadShoppingList: async () => {
    try {
      const shoppingList = await getShoppingList();
      set({ shoppingList });
    } catch (error) {
      console.error("Error loading shopping list:", error);
    }
  },

  loadExpenses: async () => {
    try {
      const expenses = await getExpenses();
      set({ expenses });
    } catch (error) {
      console.error("Error loading expenses:", error);
    }
  },

  loadCashClosings: async () => {
    try {
      const cashClosings = await getCashClosings();
      set({ cashClosings });
    } catch (error) {
      console.error("Error loading cash closings:", error);
    }
  },

  // --- LÓGICA DE CLIENTES ---
  addClient: async (clientData) => {
    try {
      const clientId = await addClient({
        ...clientData,
        creditBalance: 0,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      });
      
      // Reload clients to reflect the change
      await get().loadClients();
      
      return { success: true, id: clientId };
    } catch (error) {
      console.error("Error adding client:", error);
      return { success: false, error: error.message };
    }
  },
  updateClient: async (id, updatedData) => {
    try {
      // Implementation will depend on your Firestore update function
      // For now, we'll reload clients after updating
      await get().loadClients();
      
      return { success: true };
    } catch (error) {
      console.error("Error updating client:", error);
      return { success: false, error: error.message };
    }
  },
  deleteClient: async (id) => {
    try {
      // Implementation will depend on your Firestore delete function
      // For now, we'll reload clients after deletion
      await get().loadClients();
      
      return { success: true };
    } catch (error) {
      console.error("Error deleting client:", error);
      return { success: false, error: error.message };
    }
  },
  grantCredit: async (clientId, amount) => {
    try {
      // Implementation will depend on your Firestore update function
      // For now, we'll reload clients after updating credit
      await get().loadClients();
      
      return { success: true };
    } catch (error) {
      console.error("Error granting credit:", error);
      return { success: false, error: error.message };
    }
  },
  recordPayment: async (clientId, amount) => {
    try {
      // Implementation will depend on your Firestore update function
      // For now, we'll reload clients after recording payment
      await get().loadClients();
      
      return { success: true };
    } catch (error) {
      console.error("Error recording payment:", error);
      return { success: false, error: error.message };
    }
  },
  liquidateCredit: async (clientId) => {
    try {
      // Implementation will depend on your Firestore update function
      // For now, we'll reload clients after liquidating credit
      await get().loadClients();
      
      return { success: true };
    } catch (error) {
      console.error("Error liquidating credit:", error);
      return { success: false, error: error.message };
    }
  },
  addReminder: (reminderData) => {
    const newReminder = { ...reminderData, id: `rem-${Date.now()}`, isConcluded: false, createdAt: new Date().toISOString() };
    set(state => ({ reminders: [...state.reminders, newReminder] }));
  },

  markReminderAsConcluded: (id) => {
    set(state => ({
      reminders: state.reminders.map(rem => rem.id === id ? { ...rem, isConcluded: true } : rem)
    }));
  },
  },

  alerts: [],
  reminders: [], // New state for reminders

  // Configuración
  alertSettings: {
    daysBeforeExpiration: 30,
    cardCommissionRate: 0.04, // 4% commission
  },

  // --- ACTIONS ---

  // Inicialización
  initialize: () => {
    set({
      products: localProducts,
      categories: localCategories,
      users: localUsers,
      stores: localStores,
      inventoryBatches: localInventoryBatches,
    });
    get().checkAllAlerts();
  },

  // Autenticación
  handleLogin: async (email, password) => {
    try {
      // Sign in with Firebase
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      const user = userCredential.user;
      
      // Fetch user details from Firestore
      const userDoc = await getUser(user.uid);
      if (userDoc) {
        set({
          currentUser: userDoc,
          currentView: userDoc.role === 'admin' || userDoc.role === 'gerente' ? 'admin-dashboard' : 'pos',
        });
        // Initialize the app data after login
        await get().initialize();
        return { success: true, user: userDoc };
      } else {
        return { success: false, error: "Usuario no encontrado en la base de datos" };
      }
    } catch (error) {
      if (error.code === 'auth/user-not-found') {
        return { success: false, error: "Usuario no encontrado" };
      } else if (error.code === 'auth/wrong-password') {
        return { success: false, error: "Contraseña incorrecta" };
      } else {
        return { success: false, error: `Error de autenticación: ${error.message}` };
      }
    }
  },
  handleLogout: () => {
    set({ 
      currentUser: null, 
      currentView: 'login', 
      cart: [],
      // Reset all data to empty arrays
      products: [],
      categories: [],
      users: [],
      stores: [],
      clients: [],
      inventoryBatches: [],
      transfers: [],
      salesHistory: [],
      expenses: [],
      shoppingList: [],
      cashClosings: [],
    });
  },

  // Navegación
  setCurrentView: (view) => set({ currentView: view }),
  setActiveTab: (tab) => set({ activeTab: tab }),

  // Carrito
  addToCart: (product) => {
    const { currentUser, inventoryBatches, cart } = get();
    const storeId = currentUser?.storeId;

    if (!storeId) {
      console.error("No store ID found for current user. Cannot add to cart.");
      return;
    }

    const stockInLocation = inventoryBatches
      .filter(batch => batch.productId === product.id && batch.locationId === storeId)
      .reduce((sum, batch) => sum + batch.quantity, 0);

    const itemInCart = cart.find(item => item.id === product.id);
    const quantityInCart = itemInCart ? itemInCart.quantity : 0;

    if (quantityInCart >= stockInLocation) {
      console.warn(`Cannot add more ${product.name} to cart. Stock limit reached.`);
      // Here you would typically show a user-facing error message.
      return; 
    }

    set((state) => {
      const existingItem = state.cart.find(item => item.id === product.id);
      if (existingItem) {
        return {
          cart: state.cart.map(item =>
            item.id === product.id ? { ...item, quantity: item.quantity + 1 } : item
          ),
        };
      } else {
        return {
          cart: [...state.cart, { ...product, quantity: 1 }],
        };
      }
    });
  },
  removeFromCart: (productId) => set((state) => ({
    cart: state.cart.filter(item => item.id !== productId),
  })),

  updateCartItemQuantity: (productId, quantity) => set((state) => ({
    cart: state.cart.map(item =>
      item.id === productId ? { ...item, quantity: quantity } : item
    ).filter(item => item.quantity > 0),
  })),

  handleCheckout: async (payment) => {
    const { cart, currentUser, inventoryBatches, discount, note } = get();
    const { cash, card, cardCommission, commissionInCash } = payment;
    const storeId = currentUser?.storeId;

    if (!storeId) {
      console.error("Checkout failed: No store ID for current user.");
      return;
    }

    // Create a copy of inventory batches to update
    let updatedBatches = JSON.parse(JSON.stringify(inventoryBatches)); // Deep copy to avoid mutation issues

    // Deduct quantities from inventory batches
    for (const item of cart) {
      let quantityToDeduct = item.quantity;

      const relevantBatches = updatedBatches
        .filter(b => b.productId === item.id && b.locationId === storeId)
        .sort((a, b) => new Date(a.expirationDate) - new Date(b.expirationDate));

      for (const batch of relevantBatches) {
        if (quantityToDeduct <= 0) break;

        const deductAmount = Math.min(quantityToDeduct, batch.quantity);
        batch.quantity -= deductAmount;
        quantityToDeduct -= deductAmount;
      }
    }

    const subtotal = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);
    let finalTotal = subtotal;

    if (discount.type === 'percentage') {
      finalTotal = subtotal * (1 - discount.value / 100);
    } else if (discount.type === 'amount') {
      finalTotal = subtotal - discount.value;
    }

    // Apply card commission
    if (cardCommission > 0 && !commissionInCash) {
      finalTotal += cardCommission;
    }

    const saleDetails = {
      cart: cart.map(item => ({...item})), // Create a copy to avoid reference issues
      subtotal: subtotal,
      discount: discount,
      note: note,
      total: finalTotal,
      cash: cash,
      card: card,
      cardCommission: cardCommission,
      commissionInCash: commissionInCash,
      cashier: currentUser ? currentUser.name : 'Unknown',
      storeId: storeId,
      date: new Date().toISOString(), // This will be set by Firebase serverTimestamp
    };

    try {
      // Save the sale to Firebase
      const saleId = await addSale(saleDetails);
      
      // Update inventory batches in Firebase
      // For simplicity, we'll reload inventory after checkout
      await get().loadInventoryBatches();

      // Update the state
      set({ 
        cart: [], 
        lastSale: { ...saleDetails, saleId }, // Add the generated sale ID
        salesHistory: [...get().salesHistory, { ...saleDetails, saleId }], // Add sale to history
        discount: { type: 'none', value: 0 }, // Reset discount after checkout
        note: '', // Reset note after checkout
      });

      get().checkAllAlerts();
      
      return { success: true, saleId };
    } catch (error) {
      console.error("Error processing checkout:", error);
      return { success: false, error: error.message };
    }
  },

  // --- LÓGICA DE TRANSFERENCIAS ---
  createTransferRequest: async ({ items }) => {
    const { currentUser, stores } = get();
    const destinationStore = stores.find(s => s.id === currentUser.storeId);

    if (!destinationStore) {
      console.error("Cannot create transfer request: User has no assigned store.");
      return { success: false, error: "Usuario no tiene tienda asignada" };
    }

    try {
      const newTransfer = {
        originLocationId: 'bodega-central',
        destinationLocationId: destinationStore.id,
        requestedBy: currentUser.uid,
        createdAt: new Date().toISOString(),
        status: 'solicitado',
        items: items, // [{ productId, productName, requestedQuantity }]
        history: [{ status: 'solicitado', date: new Date().toISOString(), userId: currentUser.uid }],
      };

      // Add transfer to Firestore
      const { addDoc, collection } = await import('firebase/firestore');
      const docRef = await addDoc(collection(db, 'transfers'), newTransfer);
      
      // Reload transfers to reflect the change
      await get().loadTransfers();
      
      return { success: true, id: docRef.id };
    } catch (error) {
      console.error("Error creating transfer request:", error);
      return { success: false, error: error.message };
    }
  },
  
  approveTransfer: async (transferId) => {
    try {
      const { currentUser } = get();
      const { doc, updateDoc, getDoc } = await import('firebase/firestore');
      const transferRef = doc(db, 'transfers', transferId);
      const transferDoc = await getDoc(transferRef);
      
      if (transferDoc.exists()) {
        const updatedTransfer = {
          status: 'aprobado',
          history: [
            ...transferDoc.data().history, 
            { status: 'aprobado', date: new Date().toISOString(), userId: currentUser.uid }
          ]
        };
        
        await updateDoc(transferRef, updatedTransfer);
        
        // Reload transfers to reflect the change
        await get().loadTransfers();
        
        return { success: true };
      } else {
        return { success: false, error: "Transferencia no encontrada" };
      }
    } catch (error) {
      console.error("Error approving transfer:", error);
      return { success: false, error: error.message };
    }
  },

  shipTransfer: async (transferId, sentItems) => {
    try {
      const { currentUser } = get();
      const { doc, updateDoc, getDoc, getFirestore } = await import('firebase/firestore');
      const { getProducts, getInventoryBatches, addInventoryBatch } = await import('../utils/firestore');
      
      // Get current transfer document
      const transferRef = doc(db, 'transfers', transferId);
      const transferDoc = await getDoc(transferRef);
      
      if (!transferDoc.exists()) {
        return { success: false, error: "Transferencia no encontrada" };
      }
      
      const currentTransfer = transferDoc.data();
      const updatedTransfer = {
        status: 'enviado',
        items: currentTransfer.items.map(origItem => {
          const sentItem = sentItems.find(si => si.productId === origItem.productId);
          return sentItem ? { ...origItem, sentQuantity: sentItem.sentQuantity } : origItem;
        }),
        history: [
          ...currentTransfer.history,
          { status: 'enviado', date: new Date().toISOString(), userId: currentUser.uid }
        ]
      };
      
      // Update the transfer document
      await updateDoc(transferRef, updatedTransfer);
      
      // Update inventory batches by deducting stock from origin location
      for (const item of sentItems) {
        let quantityToDeduct = item.sentQuantity;
        const relevantBatches = await getInventoryBatches();
        const batchesAtOrigin = relevantBatches
          .filter(b => b.productId === item.id && b.locationId === 'bodega-central')
          .sort((a, b) => new Date(a.expirationDate) - new Date(b.expirationDate));
        
        // For each batch at origin, deduct the necessary quantity
        for (const batch of batchesAtOrigin) {
          if (quantityToDeduct <= 0) break;
          const deductAmount = Math.min(quantityToDeduct, batch.quantity);
          
          // Update the batch quantity in Firestore
          const batchRef = doc(db, 'inventoryBatches', batch.id || batch.inventoryId);
          await updateDoc(batchRef, { quantity: batch.quantity - deductAmount });
          
          quantityToDeduct -= deductAmount;
        }
      }
      
      // Reload all affected data
      await get().loadTransfers();
      await get().loadInventoryBatches();
      get().checkAllAlerts();
      
      return { success: true };
    } catch (error) {
      console.error("Error shipping transfer:", error);
      return { success: false, error: error.message };
    }
  },

  receiveTransfer: async (transferId, receivedItems) => {
    try {
      const { currentUser } = get();
      const { doc, updateDoc, getDoc } = await import('firebase/firestore');
      const { addInventoryBatch } = await import('../utils/firestore');
      
      // Get the transfer document
      const transferRef = doc(db, 'transfers', transferId);
      const transferDoc = await getDoc(transferRef);
      
      if (!transferDoc.exists()) {
        return { success: false, error: "Transferencia no encontrada" };
      }
      
      const currentTransfer = transferDoc.data();
      const destinationId = currentTransfer.destinationLocationId;
      
      // Update the transfer document
      const updatedTransfer = {
        status: 'recibido',
        items: currentTransfer.items.map(origItem => { 
          const receivedItem = receivedItems.find(ri => ri.productId === origItem.productId);
          return receivedItem ? { ...origItem, receivedQuantity: receivedItem.receivedQuantity } : origItem;
        }),
        history: [
          ...currentTransfer.history,
          { status: 'recibido', date: new Date().toISOString(), userId: currentUser.uid }
        ]
      };
      
      await updateDoc(transferRef, updatedTransfer);
      
      // Add the received items to destination inventory
      for (const item of receivedItems) {
        await addInventoryBatch({
          productId: item.productId,
          locationId: destinationId,
          quantity: item.receivedQuantity,
          cost: 0, // This should be improved to get the real cost
          expirationDate: null, // This should come from the shipped batch
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        });
      }
      
      // Reload all affected data
      await get().loadTransfers();
      await get().loadInventoryBatches();
      get().checkAllAlerts();
      
      return { success: true };
    } catch (error) {
      console.error("Error receiving transfer:", error);
      return { success: false, error: error.message };
    }
  },

  // --- LÓGICA DE PRODUCTOS ---
  addProduct: async (productData) => {
    try {
      const { storeId, categoryId, subcategoryId, ...rest } = productData;
      
      // Add product to Firestore
      const productId = await addProduct({
        ...rest,
        categoryId,
        subcategoryId,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      });

      // Add initial inventory batch to Firestore 
      await addInventoryBatch({
        productId: productId,
        locationId: storeId,
        quantity: 0, // Initial quantity is 0, it will be added later
        cost: rest.cost || 0,
        expirationDate: rest.expirationDate || null,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });

      // Reload products and inventory to reflect the changes
      await get().loadProducts();
      await get().loadInventoryBatches();
      
      return { success: true, id: productId };
    } catch (error) {
      console.error("Error adding product:", error);
      return { success: false, error: error.message };
    }
  },

  updateProduct: async (id, updatedData) => {
    try {
      await updateProduct(id, {
        ...updatedData,
        updatedAt: new Date().toISOString()
      });

      // Reload products to reflect the changes
      await get().loadProducts();
      
      return { success: true };
    } catch (error) {
      console.error("Error updating product:", error);
      return { success: false, error: error.message };
    }
  },

  deleteProduct: (id) => {
    set(state => ({
      products: state.products.filter(product => product.id !== id)
    }));
  },
  checkAllAlerts: async () => {
    try {
      // Get most recent data from state (which should be from Firestore)
      const { inventoryBatches, products, stores, alertSettings } = get();
      const newAlerts = [];

      // 1. Alertas de Stock Bajo
      stores.forEach(store => {
        products.forEach(product => {
          const totalStockInLocation = inventoryBatches
            .filter(batch => batch.productId === product.id && batch.locationId === store.id)
            .reduce((sum, batch) => sum + batch.quantity, 0);
          
          const threshold = product.minStockThreshold[store.id];

          if (threshold !== undefined && totalStockInLocation < threshold) {
            newAlerts.push({
              id: `low-stock-${product.id}-${store.id}`,
              type: 'Stock Bajo',
              message: `Quedan ${totalStockInLocation} de ${product.name} en ${store.name}. (Mínimo: ${threshold})`,
              isRead: false,
            });
          }
        });
      });

      // 2. Alertas de Próxima Caducidad
      const today = new Date();
      const alertDate = new Date();
      alertDate.setDate(today.getDate() + alertSettings.daysBeforeExpiration);

      inventoryBatches.forEach(batch => {
        if (batch.expirationDate) {
          const expiration = new Date(batch.expirationDate);
          if (expiration > today && expiration <= alertDate) {
            const product = products.find(p => p.id === batch.productId);
            const store = stores.find(s => s.id === batch.locationId);
            newAlerts.push({
              id: `exp-${batch.inventoryId || batch.id}`,
              type: 'Próxima Caducidad',
              message: `${batch.quantity} de ${product.name} en ${store.name} vencen el ${batch.expirationDate}.`,
              isRead: false,
            });
          }
        }
      });

      set({ alerts: newAlerts });
      return { success: true };
    } catch (error) {
      console.error("Error checking alerts:", error);
      return { success: false, error: error.message };
    }
  },

  // Acción para marcar alerta como leída
  markAlertAsRead: (alertId) => {
    set(state => ({
      alerts: state.alerts.map(a => a.id === alertId ? { ...a, isRead: true } : a),
    }));
  },

  // --- LÓGICA DE GASTOS ---
  addExpense: async (expenseData) => {
    try {
      const { addDoc, collection } = await import('firebase/firestore');
      let expensesToAdd = [];
      
      if (Array.isArray(expenseData)) {
        expensesToAdd = expenseData.map(item => ({
          concept: item.name,
          amount: item.price * item.quantity,
          type: 'Compra Miscelánea',
          details: `Comprado desde lista de compras. Cantidad: ${item.quantity}`,
          date: new Date().toISOString(),
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        }));
      } else {
        expensesToAdd.push({ 
          ...expenseData, 
          date: new Date().toISOString(),
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        });
      }
      
      // Add each expense to Firestore
      const addPromises = expensesToAdd.map(expense => addDoc(collection(db, 'expenses'), expense));
      await Promise.all(addPromises);
      
      // Reload expenses to reflect changes
      await get().loadExpenses();
      
      return { success: true };
    } catch (error) {
      console.error("Error adding expense:", error);
      return { success: false, error: error.message };
    }
  },
  // --- LÓGICA DE USUARIOS ---
  addUser: (userData) => {
    const newUser = { ...userData, uid: `user-${Date.now()}` };
    set(state => ({
      users: [...state.users, newUser]
    }));
  },

  updateUser: (uid, updatedData) => {
    set(state => ({
      users: state.users.map(user => user.uid === uid ? { ...user, ...updatedData } : user)
    }));
  },

  deleteUser: (uid) => {
    set(state => ({
      users: state.users.filter(user => user.uid !== uid)
    }));
  },

  // --- LÓGICA DE CATEGORÍAS ---
  addCategory: (categoryData) => {
    const newCategory = { ...categoryData, id: `cat-${Date.now()}`, subcategories: [] };
    set(state => {
      if (newCategory.parentId) {
        const parentCategory = state.categories.find(c => c.id === newCategory.parentId);
        if (parentCategory) {
          parentCategory.subcategories.push(newCategory);
          return { categories: [...state.categories] };
        }
      }
      return { categories: [...state.categories, newCategory] };
    });
  },

  updateCategory: (id, updatedData) => {
    set(state => ({
      categories: state.categories.map(category => category.id === id ? { ...category, ...updatedData } : category)
    }));
  },

  deleteCategory: (id) => {
    set(state => ({
      categories: state.categories.filter(category => category.id !== id)
    }));
  },

  handleCashClosing: async (initialCash) => {
    try {
      const { salesHistory, currentUser } = get();
      const salesToClose = salesHistory.filter(sale => sale.cashier === currentUser.name);
      const totalSalesAmount = salesToClose.reduce((acc, sale) => acc + sale.total, 0);
      const totalCashSales = salesToClose.filter(sale => sale.cash).reduce((acc, sale) => acc + sale.cash, 0);
      const totalCardSales = salesToClose.filter(sale => sale.card).reduce((acc, sale) => acc + sale.card, 0);

      const cashClosing = {
        cashier: currentUser.name,
        initialCash: initialCash,
        totalSalesAmount: totalSalesAmount,
        totalCashSales: totalCashSales,
        totalCardSales: totalCardSales,
        finalCash: initialCash + totalCashSales,
        sales: salesToClose.map(sale => ({ ...sale })), // Create copy to avoid reference issues
        date: new Date().toISOString(),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      // Add cash closing to Firestore
      const { addDoc, collection } = await import('firebase/firestore');
      await addDoc(collection(db, 'cashClosings'), cashClosing);

      // Reload data to reflect changes
      await get().loadCashClosings();
      
      // Remove processed sales from the sales history in state
      set(state => ({
        salesHistory: state.salesHistory.filter(sale => sale.cashier !== currentUser.name),
      }));

      return { success: true };
    } catch (error) {
      console.error("Error handling cash closing:", error);
      return { success: false, error: error.message };
    }
  },

  // --- LÓGICA DE CONSUMO DE EMPLEADOS ---
  recordEmployeeConsumption: async (consumedItems, consumingUser) => {
    try {
      const { inventoryBatches } = get();
      let updatedBatches = JSON.parse(JSON.stringify(inventoryBatches));

      // Deduct stock for each consumed item
      for (const item of consumedItems) {
        let quantityToDeduct = item.quantity;

        // Find and sort relevant batches (FEFO) for the consuming user's store
        const relevantBatches = updatedBatches
          .filter(b => b.productId === item.id && b.locationId === consumingUser.storeId)
          .sort((a, b) => new Date(a.expirationDate) - new Date(b.expirationDate));

        for (const batch of relevantBatches) {
          if (quantityToDeduct <= 0) break;

          const deductAmount = Math.min(quantityToDeduct, batch.quantity);
          batch.quantity -= deductAmount;
          quantityToDeduct -= deductAmount;
        }
      }

      // Record the consumption in Firestore
      const consumptionRecord = {
        items: consumedItems.map(item => ({...item})), // Create copy to avoid reference issues
        user: consumingUser.name,
        storeId: consumingUser.storeId,
        type: 'Consumo de Empleado',
        date: new Date().toISOString(),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      // Add consumption record to Firestore (using expenses collection or a separate consumption collection)
      const { addDoc, collection } = await import('firebase/firestore');
      await addDoc(collection(db, 'expenses'), {
        ...consumptionRecord,
        concept: 'Consumo de Empleado',
        amount: 0, // Could calculate based on item prices if needed
        type: 'Consumo Interno'
      });

      // Update inventory batches in Firestore
      // For simplicity, we'll reload inventory after consumption
      await get().loadInventoryBatches();

      get().checkAllAlerts();
      
      return { success: true };
    } catch (error) {
      console.error("Error recording employee consumption:", error);
      return { success: false, error: error.message };
    }
  },

  // --- LÓGICA DE CONFIGURACIÓN DE TICKET ---
  ticketSettings: {
    headerText: '¡Gracias por tu compra!',
    footerText: 'Vuelve pronto.',
    showQrCode: true,
    fontSize: 'base',
    logoUrl: '',
  },

  updateTicketSettings: (newSettings) => {
    set(state => {
      const updatedSettings = { ...state.ticketSettings, ...newSettings };
      console.log("Saving ticketSettings to localStorage:", updatedSettings);
      localStorage.setItem('ticketSettings', JSON.stringify(updatedSettings));
      return { ticketSettings: updatedSettings };
    });
  },

  updateAlertSettings: (newSettings) => {
    set(state => {
      const updatedSettings = { ...state.alertSettings, ...newSettings };
      console.log("Saving alertSettings to localStorage:", updatedSettings);
      localStorage.setItem('alertSettings', JSON.stringify(updatedSettings));
      return { alertSettings: updatedSettings };
    });
  },

  // --- ACTIONS ---

  // Inicialización
  initialize: async () => {
    console.log("useAppStore initialize function called.");
    const storedTicketSettings = localStorage.getItem('ticketSettings');
    const storedDarkMode = localStorage.getItem('darkMode');
    let initialTicketSettings = get().ticketSettings; // Get default settings
    let darkModePreference = false; // Default to light mode

    if (storedTicketSettings) {
      const parsedSettings = JSON.parse(storedTicketSettings);
      console.log("Loading ticketSettings from localStorage:", parsedSettings);
      initialTicketSettings = { ...initialTicketSettings, ...parsedSettings }; // Merge with stored
    }

    if (storedDarkMode) {
      darkModePreference = JSON.parse(storedDarkMode);
    }

    // Initialize Firebase collections if needed
    await initializeFirebaseCollections();

    // Load data from Firebase
    await Promise.all([
      get().loadProducts(),
      get().loadCategories(), 
      get().loadUsers(),
      get().loadStores(),
      get().loadInventoryBatches(),
      get().loadSalesHistory(),
      get().loadClients(),
      get().loadTransfers(),
      get().loadShoppingList(),
      get().loadExpenses(),
      get().loadCashClosings(),
    ]);

    set({
      ticketSettings: initialTicketSettings, // Set merged settings
      darkMode: darkModePreference, // Set dark mode preference
    });
    get().checkAllAlerts();
  },

  addUser: (userData) => {
    const newUser = { ...userData, uid: `user-${Date.now()}` };
    set(state => ({
      users: [...state.users, newUser]
    }));
  },

  updateUser: (uid, updatedData) => {
    set(state => ({
      users: state.users.map(user => user.uid === uid ? { ...user, ...updatedData } : user)
    }));
  },

  deleteUser: (uid) => {
    set(state => ({
      users: state.users.filter(user => user.uid !== uid)
    }));
  },

}));



export default useAppStore;
